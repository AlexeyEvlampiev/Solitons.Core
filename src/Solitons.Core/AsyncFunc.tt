<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #><#
	int maxArgsNumber = 16;
	var argNumbers = Enumerable.Range(2, maxArgsNumber-1);
	var ordinals = new Dictionary<int, string>(){
		[01] = "first",
		[02] = "second",
		[03] = "third",
		[04] = "fourth",
		[05] = "fifth",
		[06] = "sixth",
		[07] = "seventh",
		[08] = "eighth",
		[09] = "ninth",
		[10] = "tenth",
		[11] = "eleventh",
		[12] = "twelfth",
		[13] = "thirteenth",
		[14] = "fourteenth",
		[15] = "fifteenth",
		[16] = "sixteenth",
	};
#>
using System;
using System.Threading.Tasks;
using System.Reactive;
using System.Diagnostics;
using System.Reactive.Linq;
using System.Reactive.Threading.Tasks;
using System.Runtime.CompilerServices;
namespace Solitons;

public static partial class AsyncFunc
{<# foreach(var argsNumber in argNumbers) { 
	var argTypesDecl = string.Join(", ", Enumerable
		.Range(1, argsNumber)
		.Select(i => $"T{i}"));
	var methodArgs = string.Join(", ", Enumerable
		.Range(1, argsNumber)
		.Select(i => $"T{i} arg{i}"));
	var valuesCsv = string.Join(", ", Enumerable
		.Range(1, argsNumber)
		.Select(i => $"arg{i}"));
#> 

	/// <summary>
	/// 
	/// </summary><# foreach(var ordinal in Enumerable.Range(1, argsNumber)){ #> 
	/// <typeparam name="T<#= ordinal #>">
	/// The type of the <#= ordinals[ordinal] #> parameter of the method that this delegate encapsulates.
	/// This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived.
	///</typeparam><# } #> 
	/// <param name="action"></param>
	/// <returns></returns>
	[DebuggerStepThrough]
    public static Func<<#= argTypesDecl #>,Task> Wrap<<#= argTypesDecl #>>(Action<<#= argTypesDecl #>> action) => [DebuggerStepThrough] (<#= methodArgs #>) =>
    {
        action.Invoke(<#= valuesCsv #>);
        return Task.CompletedTask;
    };

	/// <summary>
	/// 
	/// </summary><# foreach(var ordinal in Enumerable.Range(1, argsNumber)){ #> 
	/// <typeparam name="T<#= ordinal #>">
	/// The type of the <#= ordinals[ordinal] #> parameter of the method that this delegate encapsulates.
	/// This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived.
	///</typeparam><# } #> 
	/// <typeparam name="TResult"></typeparam>
	/// <param name="func"></param>
	/// <returns></returns>
	[DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Func<<#= argTypesDecl #>,Task<TResult>> Wrap<<#= argTypesDecl #>, TResult>(Func<<#= argTypesDecl #>,Task<TResult>> func) => func;

<# } #>
}

public static partial class Extensions
{<# foreach(var argsNumber in argNumbers) { 
	var argTypesDecl = string.Join(", ", Enumerable
		.Range(1, argsNumber)
		.Select(i => $"T{i}"));
	var methodArgs = string.Join(", ", Enumerable
		.Range(1, argsNumber)
		.Select(i => $"T{i} arg{i}"));
	var argsCsv = string.Join(", ", Enumerable
		.Range(1, argsNumber)
		.Select(i => $"arg{i}"));
#> 

	/// <summary>
	/// 
	/// </summary><# foreach(var ordinal in Enumerable.Range(1, argsNumber)){ #> 
	/// <typeparam name="T<#= ordinal #>">
	/// The type of the <#= ordinals[ordinal] #> parameter of the method that this delegate encapsulates.
	/// This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived.
	///</typeparam><# } #> 
	/// <typeparam name="TResult">The return value of the method that the casted delegate encapsulates.</typeparam>
	/// <typeparam name="TSignal"></typeparam>
	/// <param name="self"></param>
	/// <param name="signalFactory"></param>
	/// <returns></returns>
	[DebuggerNonUserCode]
	public static Func<<#= argTypesDecl #>, Task<TResult>> WithRetryOnResult<<#= argTypesDecl #>, TResult, TSignal>(
        this Func<<#= argTypesDecl #>, Task<TResult>> self,
        Func<IObservable<TResult>, IObservable<TSignal>> signalFactory)
    {
        return Invoke;
        [DebuggerStepThrough]
        Task<TResult> Invoke(<#= methodArgs #>)
        {
            return AsyncFunc
                .Wrap([DebuggerStepThrough]() => self.Invoke(<#= argsCsv #>))
                .WithRetryOnResult(signalFactory)
                .Invoke();
        }
    }


	
	/// <summary>
	/// 
	/// </summary><# foreach(var ordinal in Enumerable.Range(1, argsNumber)){ #> 
	/// <typeparam name="T<#= ordinal #>">
	/// The type of the <#= ordinals[ordinal] #> parameter of the method that this delegate encapsulates.
	/// This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived.
	///</typeparam><# } #> 
	/// <typeparam name="TResult"></typeparam>
	/// <typeparam name="TSignal"></typeparam>
	/// <param name="self"></param>
	/// <param name="signalFactory"></param>
	/// <returns></returns>
	[DebuggerStepThrough]
    public static Func<<#= argTypesDecl #>, Task<TResult>> WithRetryOnError<<#= argTypesDecl #>, TResult, TSignal>(
        this Func<<#= argTypesDecl #>, Task<TResult>>  self,
        Func<IObservable<Exception>, IObservable<TSignal>> signalFactory)
    {
        return Invoke;
        [DebuggerStepThrough]
        Task<TResult> Invoke(<#= methodArgs #>)
        {
            return AsyncFunc
                .Wrap([DebuggerStepThrough]() => self.Invoke(<#= argsCsv #>))
                .WithRetryOnError(signalFactory)
                .Invoke();
        }
    }


	[DebuggerStepThrough]
    public static Func<<#= argTypesDecl #>, Task> WithRetryOnError<<#= argTypesDecl #>, TSignal>(
        this Func<<#= argTypesDecl #>, Task>  self,
        Func<IObservable<Exception>, IObservable<TSignal>> signalFactory)
    {
        return Invoke;
        [DebuggerStepThrough]
        Task Invoke(<#= methodArgs #>)
        {
            return AsyncFunc
                .Wrap([DebuggerStepThrough]() => self.Invoke(<#= argsCsv #>))
                .WithRetryOnError(signalFactory)
                .Invoke();
        }
    }
	
	/// <summary>
	/// 
	/// </summary><# foreach(var ordinal in Enumerable.Range(1, argsNumber)){ #> 
	/// <typeparam name="T<#= ordinal #>">
	/// The type of the <#= ordinals[ordinal] #> parameter of the method that this delegate encapsulates.
	/// This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived.
	///</typeparam><# } #> 
	/// <typeparam name="TResult"></typeparam>
	/// <param name="self"></param><# foreach(var ordinal in Enumerable.Range(1, argsNumber)){ #> 
	/// <param name="arg<#= ordinal #>"></param><# } #> 
	/// <returns></returns>
	[DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static IObservable<TResult> ToObservable<<#= argTypesDecl #>, TResult>(
		this Func<<#= argTypesDecl #>, Task<TResult>>  self,
		<#= methodArgs #>) =>
		Observable.Defer([DebuggerStepThrough]() => self.Invoke(<#= argsCsv #>).ToObservable());
	
	
	/// <summary>
	/// 
	/// </summary><# foreach(var ordinal in Enumerable.Range(1, argsNumber)){ #> 
	/// <typeparam name="T<#= ordinal #>">
	/// The type of the <#= ordinals[ordinal] #> parameter of the method that this delegate encapsulates.
	/// This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived.
	///</typeparam><# } #> 
	/// <param name="self"></param><# foreach(var ordinal in Enumerable.Range(1, argsNumber)){ #> 
	/// <param name="arg<#= ordinal #>"></param><# } #> 
	/// <returns></returns>
	[DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static IObservable<Unit> ToObservable<<#= argTypesDecl #>>(
		this Func<<#= argTypesDecl #>, Task> self,
		<#= methodArgs #>) =>
		Observable.Defer([DebuggerStepThrough]() => self.Invoke(<#= argsCsv #>).ToObservable());
	
	
	<# } #> 
}